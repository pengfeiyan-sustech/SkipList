# 跳表的层级

通过随机过程来选择层级：
```
想象你在玩抛硬币游戏，决定你在游戏中可以前进多远：

起点：每当添加一个新元素，从地面层（即跳表的最底层，第0层）开始
抛硬币决定层级：
正面：向上升一层并继续抛硬币
反面：停止升层，确定当前层级作为元素的最终层级
重复过程：持续此过程直至得到反面为止

这个随机过程的结果是：
许多元素会停留在较低层级，一部分元素会到达较高层级，极少数元素可能会到达非常高的层级。
```
具体代码实现：
```cpp
template <typename K, typename V>
int SkipList<K, V>::get_random_level() {
   // 初始化层级：每个节点至少出现在第一层。(节点的forward数组至少有一个元素，存储最底层的下一个节点指针)
   int k = 1;
   // 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。
   while (rand() % 2) {
      k++;
   }
   // 层级限制：确保节点层级不超过最大值 _max_level。
   k = (k < _max_level) ? k : _max_level;
   // 返回层级：返回确定的层级值，决定节点插入的层。
   return k;
};
```
这个函数通过简单的随机过程（模拟抛硬币），以概率方式决定节点的层级，同时确保层级不会超过设定的最大值。这种随机层级分配策略有助于保持跳表的性能，确保操作（如搜索、插入、删除）的时间复杂度在平均情况下接近 O(log n)。